"""
   풍선 터트리기(투포인터, 아이디어)

   일렬로 나열된 n개의 풍선
   모든 풍선에는 서로 다른 숫자가 써져있다.

   단 1개만 남을 때까지 계속 터트리려고 합니다.


   인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 "최대 1번만" 할 수 있습니다.
   인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

   위에 서술된 규칙대로 풍선들을 1개만 남을 때까지,
   터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return

   1 <= a.length <= 1_000_000
   -1_000_000_000 <= a의 원소 <= 1_000_000_000

   사고과정.

   a의 길이가 상당히 길다.... (100만)

   a의 원소가 2개일때, 2개다 남을수있음.
   a의 원소가 3개일때

    1. a > b < c  => 3
    2. a > b > c  =>
    3. a < b > c  =>
    4. a < b < c  =>

    모르겠다...

    아이디어.

    특정 풍선이 끝까지 살아 남으려면,

    (left) 특정숫자 (right)
    특정 숫자를 기준으로 자신이 가장 작다면, 한쪽으로라도.
    그렇다면 반대쪽의 숫자가 자신보다 크던, 작던
    더 작은 풍선을 터트리는 행위는 "최대 1번만"의 규칙에 의해 살아남을 수 있다..
"""

# INF = 1_000_000_000
#
#
# def solution(a):
#     answer = 0
#
#     check = [0] * len(a)
#
#     left_min = INF
#     # 각 풍선의 숫자가 왼쪽에서 최솟값이 될 수 있는가?
#     for i in range(len(a)):
#         if a[i] < left_min:
#             left_min = a[i]
#             check[i] = 1
#
#     right_min = INF
#     # 각 풍선의 숫자가 오른쪽에서 최솟값이 될 수 있는가?
#     for i in range(len(a)-1, -1, -1):
#         if a[i] < right_min:
#             right_min = a[i]
#             check[i] = 1
#
#     answer = sum(check)
#     return answer